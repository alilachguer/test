<?php

namespace UM\JdmapiBundle\Repository;

/**
 * nodeRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class NodeRepository extends \Doctrine\ORM\EntityRepository
{
    protected $stmts = array();

    /*
     * Teste l'existence d'un node/term dans la base locale
     * en recherchant son ID qu'elle renvoieS
     */
    public function existsLocally(String $urlencodedterm)
    {
        $em = $this->getEntityManager();
        $conn = $em->getConnection();

        // Si la requête préparée existe on la récupère et on l'exécute
        if (isset($this->stmts["existsLocally"]) && is_object($this->stmts["existsLocally"])
            && "Doctrine\DBAL\Driver\Statement" == get_class($this->stmts["existsLocally"])) {
            $stmt = $this->stmts["existsLocally"];
            $stmt->execute(array($urlencodedterm));

        // Sinon on crée la requête on l'exécute et on l'enregistre
        } else {
            $sql = "SELECT N.id FROM node N WHERE N.name = ? AND is_main = 1 LIMIT 1";

            $stmt = $conn->executeQuery($sql, array($urlencodedterm));
            $this->stmts["existsLocally"] = $stmt;
        }
        $idRrow = $stmt->fetch();
        return $idRrow["id"] ?? 0;
    }

    /*
    * Insertion ou mise à jour d'un terme isolé avec le statut "main" (terme principal)
    * à réaliser après l'insertion des noeuds et relations pour ce terme.
    */
    public function insertMain(array $data) {

        echo "<p>TEST DANS NodeRepository</p>";

        // Récupération de l'ID d'un terme existant
/*        if (is_null($id)) {
            $row = $this->findBy(array("name" => $urlencodedterm));

            var_dump($id);
            exit();

            if (empty($row) || !isset($row[0]) || !is_object($row[0])) {
                throw new \Exception("ID du terme principal introuvable (donnée requise).");
            } else {
                $node = $row[0];
                $id = $node->getId();
            }
        }*/

        $sql = "INSERT INTO node (id, name, id_type, weight, formatted_name, is_main) 
                VALUES (?, ?, ?, ?, ?, 1)
                ON DUPLICATE KEY UPDATE 
                name = VALUES(name),
                id_type = VALUES(id_type),
                weight = VALUES(weight),
                formatted_name = VALUES(formatted_name),
                is_main = 1;";

        $em = $this->getEntityManager();
        $insertStmt = $em->getConnection()->prepare($sql);

        $insertStmt->bindValue(1, /*id*/ $data["id"]);
        $insertStmt->bindValue(2, /*name*/ $data["name"]);
        $insertStmt->bindValue(3, /*type*/ $data["type"]);
        $insertStmt->bindValue(4, /*weight*/ $data["weight"]);
        $insertStmt->bindValue(5, /*formatted_name*/ $data["formatted_name"]);

        $insertStmt->execute();
    }

    /*
     * Renvoie les les données pour un noeud d'ID $nodeId
     * avec ou sans ses relation
     */
    public function get(string $nodeId, bool $excludeRelout, bool $excludeRelin,
                        String $relTypes = "all", String $nodeTypes = "all",
                        String $sortDirection1 = "DESC", String $sortDirection2 = "DESC")
    {
        // Pas de filtrage par défaut
        $filterNodeType = "false";
        $filterRelType = "false";
        $patternIdSet = "/(\d+,?)*/";

        // Filtrage par type de noeuds actif
        if ("" !== $nodeTypes && preg_match($patternIdSet, $nodeTypes) && "all" !== $nodeTypes) {
            $filterNodeType = "true";
        }

        // Filtrage par type des relations actif
        if ("" !== $relTypes && preg_match($patternIdSet, $relTypes) && "all" !== $relTypes) {
            $filterRelType = "true";
        }

        // Si la requête préparée correspondante existe déjà on la récupère et on l'exécute
        if (isset($this->stmts["get"][$filterRelType][$filterNodeType][$sortDirection1][$sortDirection2])
            && is_object($this->stmts["get"][$filterRelType][$filterNodeType][$sortDirection1][$sortDirection2])
            && "Doctrine\DBAL\Driver\Statement" == get_class($this->stmts["get"][$filterRelType][$filterNodeType][$sortDirection1][$sortDirection2])) {
            $stmt = $this->stmts["get"][$filterRelType][$filterNodeType][$sortDirection1][$sortDirection2];
            $stmt->execute(array($nodeId));
        // Sinon on crée la requête on l'exécute et on l'enregistre
        } else {

            $em = $this->getEntityManager();
            $conn = $em->getConnection();
            $select = "
                SELECT                 
                N.id AS main_node_id,
                N.name AS main_node_name,
                N.id_type AS main_node_id_type,
                N.weight AS main_node_weight,
                N.formatted_name AS main_node_formatted_name,
                --
                D.id AS rel_node_id,
                D.name AS rel_node_name, 
                D.id_type AS rel_node_id_type,
                D.weight AS rel_node_weight,
                D.formatted_name AS rel_node_formatted_name,
                D.is_main AS rel_node_is_main,
                --
                R.id AS id_rel,
                R.id_node AS id_node_rel,
                R.id_node2 AS id_node2_rel,
                R.id_type AS id_type_rel,
                R.weight AS weight_rel,
                (R.id_node2 = N.id) AS is_relin,
                (R.id_node = N.id) AS is_relout 
                ";

            $from = "FROM node N, relation R, node D 
                ";
            $where = "WHERE N.id = ?                 
                 AND (
                    -- Relation entrante
                    (N.id = R.id_node2 AND R.id_node = D.id)
                    OR
                    -- Relation sortante
                    (N.id = R.id_node AND R.id_node2 = D.id)
                  )
                 ";
            $orderBy = "ORDER BY is_relin DESC, weight_rel DESC";

            if ($excludeRelin) {
                // AND is_relin = 0
                $where .= " AND (R.id_node2 = N.id) = 0 
                ";
                $excludeRelin = "true"; // String pour clé tableau stockage Statement
            }

            if ($excludeRelout) {
                // AND is_relout = 0
                $where .= " AND (R.id_node = N.id) = 0 
                   ";
                $excludeRelout = "true"; // String pour clé tableau stockage Statement
            }

            //**********************************************
            // Filtrage par type de relations
            //**********************************************
            if ("true" === $filterRelType) {
                $where .= "AND R.id_type IN(" . trim($relTypes, ",") .") ";
            }

            //**********************************************
            // Filtrage par type de noeuds
            //**********************************************
            if ("true" === $filterNodeType) {
                $where .= "AND D.id_type IN(" . trim($nodeTypes, ",") . ") ";
            }

            $sql = $select . $from . $where . $orderBy;

//            echo "<pre>";
//            echo "\$sql = $sql";
//            echo "</pre>";
//            exit();
            
            $stmt = $conn->executeQuery($sql, array($nodeId));
            $this->stmts["get"][$excludeRelin][$excludeRelout][$filterNodeType][$filterRelType][$sortDirection1][$sortDirection2] = $stmt;
        }

//        echo "<pre>";
//        var_dump($stmt->fetchAll());
//        echo "</pre>";
//        exit();

        return $stmt->fetchAll();
    }


}
