<?php

namespace UM\JdmapiBundle\Repository;

/**
 * nodeRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class NodeRepository extends \Doctrine\ORM\EntityRepository
{
    protected $stmts = array();

    /*
     * Teste l'existence d'un node/term dans la base locale
     * en recherchant son ID qu'elle renvoieS
     */
    public function existsLocally(String $urlencodedterm)
    {
        $em = $this->getEntityManager();
        $conn = $em->getConnection();

        // Si la requête préparée existe on la récupère et on l'exécute
        if (isset($this->stmts["existsLocally"]) && is_object($this->stmts["existsLocally"])
            && "Doctrine\DBAL\Driver\Statement" == get_class($this->stmts["existsLocally"])) {
            $stmt = $this->stmts["existsLocally"];
            $stmt->execute(array($urlencodedterm));

        // Sinon on crée la requête on l'exécute et on l'enregistre
        } else {
            $sql = "SELECT N.id FROM node N WHERE N.name = ? AND is_main = 1 LIMIT 1";

            $stmt = $conn->executeQuery($sql, array($urlencodedterm));
            $this->stmts["existsLocally"] = $stmt;
        }
        $idRrow = $stmt->fetch();
        return $idRrow["id"] ?? 0;
    }

    /*
    * Insertion ou mise à jour d'un terme isolé avec le statut "main" (terme principal)
    * à réaliser après l'insertion des noeuds et relations pour ce terme.
    */
    public function insertMain(array $data) {

        echo "<p>TEST DANS NodeRepository</p>";

        // Récupération de l'ID d'un terme existant
/*        if (is_null($id)) {
            $row = $this->findBy(array("name" => $urlencodedterm));

            var_dump($id);
            exit();

            if (empty($row) || !isset($row[0]) || !is_object($row[0])) {
                throw new \Exception("ID du terme principal introuvable (donnée requise).");
            } else {
                $node = $row[0];
                $id = $node->getId();
            }
        }*/

        $sql = "INSERT INTO node (id, name, id_type, weight, formatted_name, is_main) 
                VALUES (?, ?, ?, ?, ?, 1)
                ON DUPLICATE KEY UPDATE 
                name = VALUES(name),
                id_type = VALUES(id_type),
                weight = VALUES(weight),
                formatted_name = VALUES(formatted_name),
                is_main = 1;";

        $em = $this->getEntityManager();
        $insertStmt = $em->getConnection()->prepare($sql);

        $insertStmt->bindValue(1, /*id*/ $data["id"]);
        $insertStmt->bindValue(2, /*name*/ $data["name"]);
        $insertStmt->bindValue(3, /*type*/ $data["type"]);
        $insertStmt->bindValue(4, /*weight*/ $data["weight"]);
        $insertStmt->bindValue(5, /*formatted_name*/ $data["formatted_name"]);

        $insertStmt->execute();
    }

    /*
     * Renvoie les les données pour un noeud d'ID $nodeId
     * avec ou sans ses relation
     */
    public function get(string $nodeId, bool $excludeRelout, bool $excludeRelin,
                        String $relTypes = "all", String $nodeTypes = "all", string $sortDirection = "DESC")
    {
        // Pas de filtrage par défaut
        $filterNodeType = "false";
        $filterRelType = "false";
        $patternIdSet = "/(\d+,?)*/";

        // Filtrage par type de noeuds actif
        if (!empty($nodeTypes) && preg_match($patternIdSet, $nodeTypes) && "all" !== $nodeTypes) {
            $filterNodeType = "true";
        }

        // Filtrage par type des relations actif
        if (!empty($relTypes) && preg_match($patternIdSet, $relTypes) && "all" !== $relTypes) {
            $filterRelType = "true";
        }

        // Si la requête préparée correspondante existe on la récupère et on l'exécute
        if (isset($this->stmts["get"][$filterRelType][$filterNodeType][$sortDirection])
            && is_object($this->stmts["get"][$filterRelType][$filterNodeType][$sortDirection])
            && "Doctrine\DBAL\Driver\Statement" == get_class($this->stmts["get"][$filterRelType][$filterNodeType][$sortDirection])) {
            $stmt = $this->stmts["get"][$filterRelType][$filterNodeType][$sortDirection];
            $stmt->execute(array($nodeId));
        // Sinon on crée la requête on l'exécute et on l'enregistre
        } else {

            $em = $this->getEntityManager();
            $conn = $em->getConnection();
            $select = "SELECT N.*,";
            $from = "FROM node N ";
            $where = "WHERE N.id = ? ";
            $orderBy = "ORDER BY N.weight $sortDirection;";

            // Inclusion des relation entrantes ou/et sortantes (les 2 par défaut)
            if (!$excludeRelout || !$excludeRelin) {

                // $where .= "AND (";

                if (!$excludeRelin) {

                    $select .= "RI.id AS id_relin, 
                          RI.id_node AS id_node_relin, 
                          RI.id_type AS id_type_relin, 
                          RI.weight AS weight_relin,";

                    $from .= " LEFT JOIN relation RI ON N.id = RI.id_node2 ";

                } else {
                    $excludeRelin = "true"; // String pour clé tableau stockage Statement
                }

                if (!$excludeRelout) {

                    $select .= "RO.id AS id_relin, 
                          RO.id_node2 AS id_node_relout, 
                          RO.id_type AS id_type_relout, 
                          RO.weight AS weight_relout,";

                    $from .= " LEFT JOIN relation RO ON N.id = RO.id_node ";

                } else {
                    $excludeRelout = "true"; // String pour clé tableau stockage Statement
                }

                // $where .= ") ";

                //**********************************************
                // Filtrage par type de relations
                //**********************************************

                // Filtrage par type des relations
                if ("true" === $filterRelType) {
                    $where .= "AND RI.id_type IN('" . trim($relTypes, ",") ."') ";
                }

                //**********************************************
                // Filtrage par type de noeuds
                //**********************************************

                // Filtrage par type des relations sortantes
                if ("true" === $filterNodeType) {
//                    $from .= ", nodeType NT ";
//                    $where .= "N.id = NT.id AND NT.id IN('" . implode("','", $filter["nodetype"]) . "') ";
                    $where .= "AND N.id_type IN('" . trim($nodeTypes, ",") . "') ";
                }
             }

            // Suppression virgule finale
            $select = substr($select, 0, strlen($select) - 1) . " ";

            $sql = $select . $from . $where . $orderBy;

//            echo "<pre>";
//            echo "\$sql = $sql";
//            echo "</pre>";
//            exit();
            
            $stmt = $conn->executeQuery($sql, array($nodeId));
            $this->stmts["get"][$excludeRelin][$excludeRelout][$filterNodeType][$filterRelType][$sortDirection] = $stmt;
        }

//        echo "<pre>";
//        var_dump($stmt->fetchAll());
//        echo "</pre>";
//        exit();

        return $stmt->fetchAll();
    }


}
